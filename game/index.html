<!DOCTYPE html>
<html>
  <head>
    <title>Top-Down Roguelike</title>
    <style>
      canvas {
        border: 1px solid black;
      }

      #healthBar {
        position: absolute;
        top: 10px;
        left: 10px;
        height: 20px;
        border: 1px solid black;
        background-color: lightgreen;
      }
    </style>
  </head>
  <body>
    <canvas id="gameCanvas" width="480" height="480"></canvas>
    <script>
      // Game settings
      const TILE_SIZE = 32;
      const MAP_WIDTH = 15;
      const MAP_HEIGHT = 15;
      const ENEMY_MOVE_DELAY = 1000; // Delay in milliseconds
      const FRAME_TIME = 1000 / 60; // Time per frame for 60 fps

      // Player state
      let playerX = Math.floor(MAP_WIDTH / 2);
      let playerY = Math.floor(MAP_HEIGHT / 2);
      let playerHealth = 100;

      // Enemy state
      let enemies = [
        { x: 3, y: 5 },
        { x: 8, y: 10 },
        { x: 12, y: 2 },
      ];

      // Keyboard input handling
      document.addEventListener("keydown", handleKeyDown);

      // Canvas initialization
      const canvas = document.getElementById("gameCanvas");
      const context = canvas.getContext("2d");

      // Health bar initialization
      const healthBar = document.createElement("div");
      healthBar.id = "healthBar";
      document.body.appendChild(healthBar);

      // Animation loop variables
      let lastFrameTime = 0;

      // Animation loop
      function gameLoop(timestamp) {
        const elapsedTime = timestamp - lastFrameTime;

        // Check if enough time has passed to update the game
        if (elapsedTime > FRAME_TIME) {
          lastFrameTime = timestamp - (elapsedTime % FRAME_TIME);

          updateGame();
          drawGame();
        }

        requestAnimationFrame(gameLoop);
      }

      function handleKeyDown(event) {
        const keyPressed = event.key;

        // Movement controls
        if (keyPressed === "ArrowUp" && playerY > 0) {
          playerY--;
        } else if (keyPressed === "ArrowDown" && playerY < MAP_HEIGHT - 1) {
          playerY++;
        } else if (keyPressed === "ArrowLeft" && playerX > 0) {
          playerX--;
        } else if (keyPressed === "ArrowRight" && playerX < MAP_WIDTH - 1) {
          playerX++;
        }
      }

      function updateGame() {
        // Update enemy positions randomly with a delay
        setTimeout(() => {
          enemies.forEach((enemy) => {
            const randomDirection = Math.floor(Math.random() * 4);

            switch (randomDirection) {
              case 0: // Move up
                if (enemy.y > 0) {
                  enemy.y--;
                }
                break;
              case 1: // Move down
                if (enemy.y < MAP_HEIGHT - 1) {
                  enemy.y++;
                }
                break;
              case 2: // Move left
                if (enemy.x > 0) {
                  enemy.x--;
                }
                break;
              case 3: // Move right
                if (enemy.x < MAP_WIDTH - 1) {
                  enemy.x++;
                }
                break;
            }
          });

          updateGame(); // Call recursively to continue the enemy movement
        }, ENEMY_MOVE_DELAY);
      }

      function drawGame() {
        // Clear the canvas
        context.clearRect(0, 0, canvas.width, canvas.height);

        // Draw the player
        context.fillStyle = "red";
        context.fillRect(playerX * TILE_SIZE, playerY * TILE_SIZE, TILE_SIZE, TILE_SIZE);

        // Draw the enemies
        context.fillStyle = "blue";
        enemies.forEach((enemy) => {
          context.fillRect(enemy.x * TILE_SIZE, enemy.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
        });

        // Draw the map
        // (You can replace this with your own map generation and rendering logic)
        for (let y = 0; y < MAP_HEIGHT; y++) {
          for (let x = 0; x < MAP_WIDTH; x++) {
            context.strokeStyle = "black";
            context.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
          }
        }

        // Update health bar
        const healthBarWidth = (playerHealth / 100) * canvas.width;
        healthBar.style.width = `${healthBarWidth}px`;
      }

      gameLoop(0);
    </script>
  </body>
</html>
